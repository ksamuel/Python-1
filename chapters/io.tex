
\chapter{Migrating your strings}

Finally, we get to the point!

If you jumped to this chapter, remember we assume you perfectly undertstand what was in the previous one. Most people don't, so you may want to read it.

\section{Code file encoding}

First, you should make sure you use the best practices in your Python 2 code before moving to Python 3. To do so, ensure you know the encoding of all the code files in your project. Ideally, it should be UTF-8.

Then, add a special comment to all your files to tell Python you are using this encoding. It should be the first or second line of each file, and formatted that way: \lstinline{# coding: <encoding name>}. E.G:

\begin{py2and3}
# coding: utf-8
\end{py2and3}

You may see in tutorials fancy headers like \lstinline{# -*- coding: <encoding> -*-}. There is not need for the \lstinline{-*-}, it's an artefact that people keep copy/pasting blindly and has only a benefit if you use Emacs.

Without this line, Python 2 default to ASCII, which leads to a crash if you use any non ASCII characters in your code, even in commens. In Python 3, Python default to UTF-8.

\section{Properly using bytes(), str() and unicode()}

You need to avoid using \lstinline{bytes()} has much as possible. In Python 2, when you create a string, it's like a \lstinline{bytes()}. But if you create a string with a \textquote{u} prefix, it will create a \lstinline{unicode()}, which behaves like the Python 3 text type.

So instead of doing:

\begin{py2}
>>> msg = "This is a string"
>>> type(msg)
<type 'str'>
\end{py2}

Do:

\begin{py2}
>>> msg = u"This is a string" # note the u prefix
>>> type(msg)
<type 'unicode'>
\end{py2}

The \textquote{u} prefix does nothing in Python 3, a regular \lstinline{str()} will be created. But it's ok since they behave like \lstinline{unicode()}.

However, this is very combersome. Instead, you can use this magical import:

\begin{py2}
from __future__ import unicode_literals
\end{py2}

It must be at the top of each file, and will make all string literals create a \lstinline{unicode()}:

\begin{py2}
>>> msg = "This is a string"
>>> type(msg)
<type 'unicode'>
\end{py2}

Again, this does nothing in Python 3, which is what we want.

But careful, we don't want to turn  \textbf{all} \lstinline{str()} to \lstinline{unicode()}!

We do want to convert all strings meant to be readable by a human: help text, user messages, labels, etc.

But we do \textbf{not} want to convert bytes (mistakenly stored in a \lstinline{str()} in Python 2): network packets, pickled objects, dumps from the \lstinline{struct} module, file paths, anything to be written in a file in "b" mode, etc.

So you need to go through your files, and find those. Then mark them as \lstinline{bytes()}, by adding a \textquote{b} prefix.

\begin{py2}
>>> msg = b"This is a string"
>>> type(msg)
<type 'str'>
\end{py2}

In Python 2, this will keep it as a \lstinline{str()}. In Python 3, it will make it a \lstinline{bytes()}. Again, this is what we want.

Be careful though, indexing or iterating through a \lstinline{str()} in Python 2 gives you \lstinline{str()}:

\begin{py2}
>>> list(b'qwerty')
['q', 'w', 'e', 'r', 't', 'y']
\end{py2}

But indexing or iterating through a \lstinline{bytes()} in Python 3 will give you \lstinline{int()}:

\begin{py2}
>>> list(b'qwerty')
[113, 119, 101, 114, 116, 121]
\end{py2}

It's a rare use case, but if you happen to do that, either \lstinline(.decode()) the bytes to get a \lstinline{unicode()} in Python 2 and a \lstinline{str()} in Python 3, which will give you letters. Or call \lstinline{bytearray()} on the bytes to ensure numbers everywhere.

\begin{warning}
If you want to iterate on a \lstinline{bytes()} and get bytes of length 1 as a result in Python 3 like in Python 2, you need to do call \lstinline{bytes([value])}, not \lstinline{bytes(value)} to convert the result (note the list).

E.G, in Python 2 when you do

\begin{py2}
>>> for x in b'qwerty':
...    print(x)
q
w
e
r
t
y

\end{py2}

In Python 3, you would need to do:

\begin{py3}
>>> for x in b'qwerty':
...    print(bytes([x])) # NOT bytes(x)
q
w
e
r
t
y

\end{py3}

For a cross compatible code, use a function:

\begin{py2and3}
import sys

if sys.version_info.major >= 3:
    def iterbytes(data):
        return (bytes((x,)) for x in data)
else:
    iterbytes = bytes
\end{py2and3}

Or use tooling to provide a standardized \lstinline{bytes()} for you.

\end{warning}

\section{Opening files}

When you use \lstinline{open()} to read a file, it has two modes: binary mode, and text mode. It's very misleading, in fact, all files are binaries. Some binaries actually contains text, although most file don't. Still, not only \lstinline{open()} maintain this false dichotomy, it actually opens files in text mode by default.

If you open a so-called binary file (zip, avi, mp3, odt, doc, etc.), you should use the \textquote(b) flag:

\begin{py2and3}
with open(the_file, 'b') as f:
    data = f.read()
\end{py2and3}

There is no notion of lines, so you must use \lstinline{.read()}. You will get \lstinline{str()} in Python 2, and \lstinline{bytes()} in Python 3. There is not much to do here, just be careful of what you do with the \lstinline{bytes()} after, since we have in the previous section there are small differences.

However, if you open a so-called text file (json, csv, ini, xml, etc.), you should use the \lstinline{encoding} parameter:

\begin{py3}
with open(the_file, encoding="utf8") as f:
    for line in f:
        ...
\end{py3}

This will give you \lstinline{unicode()} in Python 2 and \lstinline{str()} in Python 3, and let you iterate line by line. This is where the previous chapter about encoding is useful. Follow its advices to choose the proper encoding.

Now, Python 2 doesn't have this parameter, but you can use \lstinline{codecs.open}:

\begin{py2and3}
if sys.version_info.major < 3:
    from codecs import open
\end{py2and3}

Please note, however, that it is much, much slower than the original Python 2 \lstinline{open()}.

\section{Fun with file paths}

File paths are one of those features that just fork 99\% of the time, until it doesn't. One reason is that Python is a cross-plateform language, but different operating systems may treat paths differently.

We usually picture file paths as strings, but infortunatly and as stated by the Python documentation itself: \textquote{some file names may not be representable as strings on Unix, so applications that need to support arbitrary file names on Unix should use bytes objects to represent path names. Vice versa, using bytes objects cannot represent all file names on Windows (in the standard mbcs encoding), hence Windows applications should use string objects to access all files.}

So Python accept both \lstinline{str()} (or \lstinline{unicode()} in Python2) and \lstinline{\bytes()} when you interract with the file system. And it will return you the same type you used as input:

\begin{py3}
>>> import os
>>> type(os.listdir(b'.')[0]) # use bytes, get bytes. In Python 2, this would return a str()
<class 'bytes'>
>>> type(os.listdir('.')[0]) # use string, get string. Same with unicode() for Python 2.
<class 'str'>
\end{py3}

And of course most Python 2 programs just use the \lstinline{str()} type to deal with path, using it like a string, while it really behaves like a \lstinline{bytes()} under the hood. Also remember, any \lstinline{str()} in Python 2 is \textbf{in the encoding of the code file}. So people create file names with implicit encoding without knowing it. Luckily most of the time, this is ASCII, as developpers all around the world have been bitten with file names enought to be very careful to choose the most basic ones when they can.

What does this mean for you ?

First, look at all the hard coded file path in your code. Decide if they should be text or arbitrary bytes and mark them accordingly. Hint: unless you are doing something very specific, and on Unix, it should be text. Check that the return value is of the type you expect (\lstinline{str()} or \lstinline{bytes()}, depending of what you passed), and that the rest of the code using this value is made to handle this type.

Then, got through all code using the \lstinline{os}, \lstinline{shutil} and \lstinline{glob} modules

File path coming from somewhere else (database, config files, etc).

Surogate escape

\section{Formatting}


formatting bytes

\section{Wait, there is I/O}

% http://www.dabeaz.com/python3io_2010/MasteringIO.pdf

Text strings in Python 3 require either 2x as much memory to store as Python 2


bad filenames were easy to create in python 2

If you ever see a \lstinline{\udcxx} character, it means that a non-decodable byte was passed in from a system interface

s.decode('utf-8','surrogateescape')

TextIOWrapper 10 times faster than codecs.open

basestring

%All backslashes in raw string literals are interpreted literally. This means that '\U' and '\u' escapes in raw strings are not treated specially. For example, r'\u20ac' is a string of 6 characters in Python 3.0, whereas in 2.6, ur'\u20ac' was the single “euro” character. (Of course, this change only affects raw string literals; the euro character is '\u20ac' in Python 3.0.)

% has been removed and reinstroduced

pathlib

%# coding: utf8

\section{file()}

\begin{py2}
from io import IOBase

if isinstance(someobj, IOBase):
\end{py2}

\section{from buffer() tp memoryview()}

Those two functions respectively create objects of the same name - a \lstinline{buffer} and a \lstinline{memoryview}. Both are a way to get a subset of something without copying it:

\begin{py2}
>>> donkey_lines = "Are we there yet ?\n" * 10000
>>> # this copies the data into a new object:
>>> for x in donkey_lines[:6]:
...    print(x)
A
r
e

w
e
>>> # those don't:
>>> for x in buffer(donkey_lines, 0, 5):
...    print(x)
A
r
e

w
e
>>> for x in memoryview(donkey_lines)[:5]:
...    print(x)
A
r
e

w
e
\end{py2}

It works on \lstinline{bytes()}, \lstinline{bytearray}, \lstinline{array.array}...Everything that implements the so-called \textquote{buffer protocol}. This is a very nice optimization that can save quite a lot of memory/CPU if you manipulate huge chunks of bytes and pass around subset of them, e.g: to files or sockets.

With the rise of performant c libs wrapped in Python (numpy, GUI toolkits, database drivers, etc.), the need for more information about the underlying data than what \lstinline{buffer()} was offering became important. \lstinline{memoryview} provides an answer to that, being able to return the shape, dimension or type or the object behind it.

\lstinline{buffer()} is not more in Python 3, just replace it with \lstinline{memoryview()}. The later exists in Python 2.7, plus it does the same thing, just better. The only difficulty will be that \lstinline{buffer()} accepts \lstinline{unicode()} objects but \lstinline{memoryview()} only accept bytes, and so you'll need to encode them.

So:

\begin{py2}
from imaginary_lib import get_tps_reports, send_those_bytes

# Imaginary code returning a lot of bytes
tps_reports = get_tps_reports()

# Imaginary code writting those bytes to a sockets by chunks
# of 1Mio
step = 3
stop = len(tps_reports)
for i in range(0, stop, step):
    send_those_bytes(buffer(tps_reports, i, step))

\end{py2}






buffer. Par exemple, pour écrire des octets sur stdout, utilisez sys.stdout.buffer.write(b'abc').

unfortunately, changing sys.stdout to accept only unicode breaks a lot of libraries that expect it to accept encoded bytestrings. – nosklo Dec 4 '09 at 19:14
