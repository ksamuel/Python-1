\makeglossaries

\newglossaryentry{callable}
{
    name=callable,
    description={A callable in Python is anything you can call, meaning you can use \lstinline{()} right after the name to get an effect. Any object with the \lstinline{__call__()} method is considered a callable, but on the day to day job, the callables you will meet are mostly functions (e.g: \lstinline{len} is a callable) or classes (e.g: \lstinline{OrderedDict} from the \lstinline{collections} module is a callable).}
}

\newglossaryentry{dunder}
{
    name=dunder,
    description={In Python, a dunder (for \textquote{double underscore}) variable, function or module is one with a named surrounded with two pairs of underscores. E.G: \lstinline{__doc__} is a dunder variable, \lstinline{__call__()} is a dunder method and \lstinline{__init__.py} is a dunder module. They signal that there is an automated behavior behind this object, and because each behavior is different, that you must read the documentation to understand it. E.g: \lstinline{__doc__} is automatically created and filled with a module docstring, \lstinline{__call__()} is automatically used when calling a function or instanciating a class and \lstinline{__init__.py} is automatically executed when importing the moduling that contains it. The benefit of this syntax is to standout in the code, so that it's very easy to spot where the magic is used. Also, it makes sure developpers have a very low probability of using a conflicting name by mistake.}
}

\newglossaryentry{generator}
{
    name=generator,
    description={A generator is specific type of \gls{iterable} that doesn't contains any element: instead, it generates them on the fly when you read it. Generators are used to save memory, and sometimes CPU, as they don't have to start by creating all the elements you can get from them. Reading a generator is usually done simply by using a \lstinline{for} loop on them. When you do so, it starts producing the elements you will process in the loop, only one at a time. This is transparent, and feels like you are looping an a list or a tuple. The difference is that generators can only be read once. }
}


\newglossaryentry{iterable}
{
    name=iterable,
    description={An iterable in Python is anything you can iterate on, meaning you can use a \lstinline{for} loop on it. Any object with the \lstinline{__iter__()} method is considered a callable. The most common iterables are lists, tuples, dicts, strings, memory views and generators.}
}

\newglossaryentry{literal}
{
    name=literal,
    description={A litteral is a datastructure that be be created using syntax - the litteral notation - instead of using a constructor. E.g: you can use the syntax \lstinline{[]} instead of \lstinline{list()} to create a list, hence, lists are litterals. In Python, strings, bytes, integers, floats, complexes, lists, tuples, sets and dictionaries are literals, while all other objects are not. }
}

\newglossaryentry{list comprehension}
{
    name=list comprehension,
    description={A special syntax of Python letting you write a \lstinline{for} loop on one line, transforming and/or filtering all the elements you loop on, resulting in a new list. E.G: \lstinline{[x*x for x in range(10) if x \% 2 == 0]} is a list comprehension, looping on \lstinline{range(10)}, filtering all numbers that are not even, and resulting in a new list containing the even numbers raised to the power of 2: \lstinline{[[0, 4, 16, 36, 64]]}. There are also dict comprehensions and set comprehensions, using curly braces (\lstinline{{}}) instead of brackets (\lstinline{[]}), and offering the same abilities, but producing dictionaries and sets. Generator expressions are the last kind of comprehension, using parenthesis instead of brackets, and resulting in a \gls{generator}}
}
